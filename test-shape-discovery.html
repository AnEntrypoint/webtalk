<!DOCTYPE html>
<html>
<head>
    <title>Full Shape Discovery</title>
</head>
<body>
    <pre id="output" style="font-size: 10px; overflow: auto; max-height: 900px;"></pre>
    <script type="module">
        const ORT_VERSION = '1.20.0';
        const ORT_CDN = `https://cdn.jsdelivr.net/npm/onnxruntime-web@${ORT_VERSION}/dist/`;

        function log(msg) {
            const el = document.getElementById('output');
            el.textContent += msg + '\n';
            el.scrollTop = el.scrollHeight;
        }

        async function test() {
            try {
                const ortModule = await import(ORT_CDN + 'ort.min.mjs');
                const ort = ortModule.default || ortModule;

                ort.env.wasm.wasmPaths = ORT_CDN;
                ort.env.wasm.simd = true;
                ort.env.wasm.numThreads = 1;

                log('Creating session...');
                const session = await ort.InferenceSession.create('/models/tts/flow_lm_main_int8.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'all'
                });

                log('Session created\n');

                // Start with known working shapes
                const shapes = {
                    'state_0': [2, 1, 1000, 16, 64],
                    'state_1': [0],
                    'state_2': [1],
                    'state_3': [2, 1, 1000, 16, 64],
                    'state_4': [], // Will discover
                };
                for (let i = 5; i <= 17; i++) {
                    shapes[`state_${i}`] = [];
                }

                const dtypes = { 'state_2': 'int64' };
                for (let i = 0; i <= 17; i++) {
                    if (i !== 2) dtypes[`state_${i}`] = 'float32';
                }

                log('Testing incrementally...\n');

                // Try progressively
                for (let testIdx = 4; testIdx <= 17; testIdx++) {
                    log(`\nTest: state_${testIdx}`);

                    const seqData = new Float32Array(1 * 1 * 32).fill(0);
                    const sequence = new ort.Tensor('float32', seqData, [1, 1, 32]);

                    const textData = new Float32Array(0);
                    const textEmb = new ort.Tensor('float32', textData, [1, 0, 1024]);

                    const stateInputs = {};

                    for (let i = 0; i <= 17; i++) {
                        const name = `state_${i}`;
                        const shape = shapes[name];
                        const dtype = dtypes[name];
                        const size = shape.reduce((a, b) => a * b, 1);

                        if (size === 0) {
                            stateInputs[name] = new ort.Tensor(dtype, new (dtype === 'int64' ? BigInt64Array : Float32Array)(0), shape);
                        } else {
                            if (dtype === 'int64') {
                                stateInputs[name] = new ort.Tensor('int64', new BigInt64Array(size).fill(BigInt(0)), shape);
                            } else {
                                stateInputs[name] = new ort.Tensor('float32', new Float32Array(size).fill(0), shape);
                            }
                        }
                    }

                    try {
                        const inputs = {
                            sequence,
                            text_embeddings: textEmb,
                            ...stateInputs
                        };

                        const result = await session.run(inputs);
                        log('  âœ“ SUCCESS! All shapes correct with state_' + testIdx + '=[1]');

                        // Log all current shapes
                        log('\nDISCOVERED SHAPES:');
                        for (const name in shapes) {
                            log(`  ${name}: [${shapes[name].join(', ')}]`);
                        }
                        break;

                    } catch (err) {
                        const msg = err.message;
                        log('  Error: ' + msg.substring(0, 120));

                        // Try to extract dimension info
                        if (msg.includes('Invalid rank')) {
                            const match = msg.match(/Expected: (\d+)/);
                            if (match) {
                                const expectedRank = parseInt(match[1]);
                                log(`    -> state_${testIdx} needs rank ${expectedRank}`);

                                if (expectedRank === 5) {
                                    shapes[`state_${testIdx}`] = [2, 1, 1000, 16, 64];
                                    log(`    -> Setting to [2, 1, 1000, 16, 64]`);
                                }
                            }
                        }
                    }
                }

            } catch (err) {
                log(`Fatal error: ${err.message}`);
                log(err.stack);
            }
        }

        test();
    </script>
</body>
</html>
